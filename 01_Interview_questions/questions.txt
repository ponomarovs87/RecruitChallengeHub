1 . Расскажите о себе.
    a. Представится, рассказать кто я по профессии расказать про опыт и в каких сферах у меня есть.
    б. Рассказать что я могу и что я умею
    в. Какие проблемы решали какие сложные задачи
    г. какие есть достижения в работе
    д. расскажите о своих сильных сторонах
    е. какие качества характера вам помогают в работе.

    ответ: 
    Ru :
        Здраствуйте я Сергей. У меня есть большой опыт в програмировании ЧПУ на языках(pyton и g-code),я работал дистанционно в Webmedia занимался там версткой на Wordpress,недавно успел поучаствовать в маштабном интересном проекте в виде beckend стажера на nodeJS, проходил обучение на React и хочу развивваться в этой сфере.Из того что умею и люблю, мне нравится работать с typescript.Недавней сложной задачей было переделывать проект (в Аргусе переделывали проект) по этому рефакторинг это было сложной задачей потому что сначала надо определить что и зачем а птотом переделать все это в нормальную структуру, самое главное что с этой задачей я справился.


2 . Расскажите про Event Loop
    ответ: 
    Ru:
        Это как по мне двигатель внутреннего сгорания но в Javascript внутрь влитают сначала микротаски потом таски потом рендер и выходит все в последовательности в которой вошло. 
        Алгоритм цикла событий(event-loop),
        1.выполнять задачи начиная с самой старой
        2.Бездействовать до появления новой задачи
    
3. Что такое замыкание
    ответ:
    Ru:
        Это комбинация функции и лексического окружения, функция обьявляется а внутри нее  запоминается переменная а возвращает она другую функцию, например функция альфа в которую приходит переменная (а) возвращается функция бетта в которую приходит переменная б и выполняет она а+в например возвращает сумму теперь мы можем с помощью обьявления переменных обьявить множество новых функций которые будут использовать как раз указанную замкнутую переменную полученную в функцию  альфа. например альфа5 =альфа(5) теперь альфа(5)= вернет 10.
    
4. Что такое promise и какие состояния у него есть
    ответ:
    Ru:
        Это удобный метод(функция) для использования асинхронного кода. состояний у него письменных 3 pending ожидание,fulfilled выполено(ответ получен),rejected (выполнен с ошибкой). но я читал на редите на самом деле есть 4 состояние 1 это ожидание, 2 выполнено а вот второй уже делится на 2 подсостояния с ошибкой или без.

5. Что такое virtual dom
    ответ:
    Ru:
        Это виртуальное html дерево, с которым удобно работать для динамических страниц. скажу на приемере реакта он создает виртуальное дерево из js елементов, а когда происходит изменение в виртуальном доме происходит сравнение и меняется только та часть в которой были измения,что облегчает нагрузку так как надо перерисовать только часть страницы.
        
6. Какие типы данных существуют в javascript
    ответ:
    Ru:
        null. - это ничего
        undefined. - значение не было присвоено
        boolean. - да/нет
        number. - это число
        string. - строка
        object. - это ассоциативные массивы с рядом дополнительных возможностей
        symbol. - для создания уникальных переменных
        BigInt. - для целых чисел произвольной длины

7. Чем let отличается от var
    ответ:
    Ru:
        let - не поддерживает повторное обьявление, let - соблюдает область видимости.
        {
            var varVrb = 1;
            var varVrb = 2;
        }
        console.log(varVrb); // 2

8. Чем var отличается от const
    ответ:
    Ru:
        const - значение должно быть обьявленно при обьявлении переменной, значение у константы не переобпеделяется, не поддерживает повторное обьявление, соблюдает облочную видимость.

9.Различие методов call apply bind
    ответ:
    Ru:
    в метод call список аргументов и мометально возвращает значение, apply масив аргуметов и мометально возвращает значение, bind список аргументов и возвращает функцию.
        var obj = { num: 2 };

        function add(a, b){
          return this.num + a + b;
        }

        const resultCall  = add.call(obj, 3, 5);
        const resultApply = add.apply(obj, [3, 5]);
        const funcBind    = add.bind(obj, 3, 5)
        const resultBind  = funcBind();

        console.log(resultCall, resultApply, resultBind);

10.В чём разница между классической функцией и стрелочной
    ответ:
    Ru:
    Значение this внутри обыкновенной функции динамически зависит от контекста вызова. Собственный this внутри стрелочной функции отсутствует и она ссылается на this внешней функции. Массив arguments внутри обыкновенной функции содержит список аргументов функции. Стрелочная функция, не имеет массива arguments (но ты можешь использовать деструктуризацию, для иммитации аналога ...args).Если в стрелочной функции содержится одна инструкция, то ты можешь использовать неявный return, даже без использования ключевого слова return. Последнее в списке, но не по важности - ты можешь использовать синтаксис стрелочных функций для внутри класса. При этом в качестве this будет выступать объект класса.

11.Какие способы изоляции стилей ты знаешь
    ответ:
    Ru:
    CSS каскадность,Уникальность именования классов,Утилитарные классы(один класс для одного дейстия, например текст красный text-color:red)
    .block1 { 
	    h1 { color: red; }
	    // прочие блоки
    	div { }
    }
    .block2 { 
	    h1 { color: green; }
	    // прочие блоки
	    div { }
    }

12.Отличия == и === в JavaScript
    ответ:
    Ru:
    Оператор == сравнивает на равенство, а вот === — на идентичность.
        const a = '0'
        const b = 0
        console.log(a == b); //true
        console.log(a === b); //false

13.Что знаешь о различии между function expression и function declaration
    ответ:
    Ru:
    Function Declaration - функция, объявленная в основном потоке кода.
    Function Expression - объявление функции в контексте какого-либо выражения, например присваивания.
    Основное отличие между ними: функции, объявленные как Function Declaration, создаются интерпретатором до выполнения кода.
    func();
    function func() {
	    console.log("fucntion decloration");
    }

14.Что такое макро и микро задачи
    ответ:
    Ru:
    Все микрозадачи завершаются до обработки каких-либо событий или рендеринга, или перехода к другой макрозадаче.
    Какой здесь будет порядок:

        code появляется первым, т.к. это обычный синхронный вызов.
        promise появляется вторым, потому что .then проходит через очередь микрозадач и выполняется после текущего синхронного кода.queueMicrotask(func),await
        timeout появляется последним, потому что это макрозадача.

    Выбрать и исполнить старейшую задачу из очереди макрозадач (например, «script»).
        Исполнить все микрозадачи:
        Пока очередь микрозадач не пуста: - Выбрать из очереди и исполнить старейшую микрозадачу
        Отрисовать изменения страницы, если они есть.
        Если очередь макрозадач пуста – подождать, пока появится макрозадача.
        Перейти к шагу 1.

15.Какими способами можно объявить переменные, назовите отличия
    ответ:
    Ru:
    let,var,const - let переменная создается в момент обьявления и можно присвоить значение позже, нельзя обявить повторно, var создается интереперетатором но значение присваевается в момент обьявления =  можно обьвить повторно, cоnst - переменная должна и создаватся и присваиваться значение одновременно нельзя обьявить повторно и нельзя поменять значение.

16.В чём разница между foreach и map
    ответ:
    Ru:
    forEach() — выполняет указанную функцию для каждого элемента массива. map() — создаёт новый массив с результатом вызова указанной функции для каждого элемента массива.
    это оба метода для работы с массивами но forEach() изменяет массив а возвращает undefined,а вот map() создает новый массив и его возвращает.
    arr.forEach((num, index) => {
        return arr[index] = num * 2;
    });

    // Результат
    // arr = [2, 4, 6, 8, 10]

    let doubled = arr.map(num => {
        return num * 2;
    });

    // Результат
    // doubled = [2, 4, 6, 8, 10]

17.В чём отличие null от undefined
    ответ:
    Ru:
    Чтобы их различать, вы можете считать undefined неожиданным отсутствием значения, а null — умышленным отсутствием значения.

18.Что такое дженерик
    ответ:
    Ru:
    Дженерики — переменные, через которые мы можем передавать тип.

19.Для чего нужен eventloop в js
    ответ:
    Ru:
    eventloop нужен для расставления приритетеов выполнения асонхронного кода и ререндеринга страницы.

20.Что такое мемоизация
    ответ:
    Ru:
    это по сути сохрание преведущих значений в хеше, что я имею вииду так это сохранять результат внутри функции и вслучае если он уже есть он снова не вычесляется а просто берется из хеша, гдето это хорошо а гдето плохо потому что мы по сути создаем много новых переменных ну или как я люблю сохраняем в один обект но обьект растет к примеру факториал вычесленный из 100 может сохранить все факториалы от 1 до 100 это по сути 100 переменных и если мы будем использовать ее один раз это не разумно а если к примеру 80 раз то мы сократим потреблямеые ресурсы на вчисление во множество раз:
    // уже знакомая нам функция memoize
const memoize = (fn) => {
  let cache = {};
  return (...args) => {
    let n = args[0];
    if (n in cache) {
      console.log('Fetching from cache', n);
      return cache[n];
    }
    else {
      console.log('Calculating result', n);
      let result = fn(n);
      cache[n] = result;
      return result;
    }
  }
}
const factorial = memoize(
  (x) => {
    if (x === 0) {
      return 1;
    }
    else {
      return x * factorial(x - 1);
    }
  }
);
console.log(factorial(5)); // вычислено
console.log(factorial(6)); // вычислено для 6, но для предыдущих значений взято из кэша

21.Можешь рассказать о семантическом вресионировании
    ответ:
    Ru:
    Учитывая номер версии МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ, следует увеличивать:

    МАЖОРНУЮ версию, когда сделаны обратно несовместимые изменения API.
    МИНОРНУЮ версию, когда вы добавляете новую функциональность, не нарушая обратной совместимости.
    ПАТЧ-версию, когда вы делаете обратно совместимые исправления.
    Дополнительные обозначения для предрелизных и билд-метаданных возможны как дополнения к МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ формату.

22.Что такое this
    ответ:
    Ru:
this — это ключевое слово в JavaScript которое содержит в себе объект (контекст) выполняемого кода.
    Сама по себе - this относится к глобальному объекту (window).
    В методе - this относится к родительскому объекту.
    В функции - this относится к глобальному объекту.
    В функции в 'strict mode' - this = undefined.
    В стрелочной функции - this относится к контексту где функция была создана.
    В событии - this ссылается на элемент запустивший событие.

23.В чём отличие хранения данных в local storage от куки
    ответ:
    Ru:

в куки данные хранятся до окончания сессии(конец сессии: закрытие вкладки или браузера) в локал сторажде хранится пока не поступит приказ удалить эти данные строго привязан к адресу сайта.

Какие бывают хуки

useState: Позволяет функциональным компонентам React использовать состояние.
useEffect: Позволяет выполнять побочные эффекты в функциональных компонентах. Например, работа с данными из API, подписка на события и т.д.
useContext: Позволяет функциональным компонентам получать доступ к контексту React.
useReducer: Предоставляет альтернативный способ управления состоянием в функциональных компонентах.
useCallback: Возвращает мемоизированную версию колбэка, который изменяется только, если изменяются одна или несколько из его зависимостей.
useMemo: Позволяет мемоизировать вычислительно затратные значения, чтобы они не пересчитывались при каждом рендере компонента.
useRef: Позволяет функциональным компонентам иметь доступ к DOM-узлам или другим значениям, которые сохраняются между рендерами.
useImperativeHandle: Позволяет функциональным компонентам изменять значение, которое передается в родительский компонент при использовании ref.
useLayoutEffect: Этот хук аналогичен useEffect, но вызывается синхронно после всех изменений DOM. Используется для выполнения манипуляций DOM, которые требуют рассчетов перед тем, как пользователь увидит изменения.
useDebugValue: Позволяет отображать дополнительную информацию о пользовательском хуке в инструментах разработчика.


24.Расскажи про области видимости

    ответ:
    Ru:

Глобальная область видимости: Переменные, объявленные вне всех функций, имеют глобальную область видимости и могут быть доступны из любой части программы.

javascript
Copy code
var globalVar = 10;

function myFunction() {
    console.log(globalVar); // Можно обратиться к глобальной переменной
}
Локальная область видимости: Переменные, объявленные внутри функции, имеют локальную область видимости и доступны только внутри этой функции.

javascript
Copy code
function myFunction() {
    var localVar = 20;
    console.log(localVar); // Можно обратиться к локальной переменной
}

console.log(localVar); // Ошибка: переменная не определена
Область видимости блока: С появлением стандарта ECMAScript 6 (ES6), JavaScript также получил область видимости переменных, ограниченную блоком (через let и const).

javascript
Copy code
if (true) {
    var x = 10; // Глобальная область видимости
    let y = 20; // Область видимости блока
    const z = 30; // Область видимости блока
}

console.log(x); // Выведет 10
console.log(y); // Ошибка: переменная недоступна
console.log(z); // Ошибка: переменная недоступна
Область видимости в JavaScript важна для понимания того, как работает код и какие переменные доступны в разных частях программы.

25.Какие бывают значения у свойства position
    ответ:
    Ru:
    Свойство `position` определяет, как элемент будет позиционироваться в документе. Есть несколько ключевых значений, которые можно присвоить этому свойству:

1. `static`: Это значение по умолчанию. Элементы с `position: static` располагаются в обычном потоке документа, и свойства `top`, `right`, `bottom`, `left` и `z-index` на них не влияют.

2. `relative`: Элемент позиционируется относительно его обычного положения в потоке документа. Указание `top`, `right`, `bottom` и `left` приведет к смещению элемента относительно того места, где он находился бы, если бы был `static`.  Элемент с `position: relative` остается в нормальном потоке документа и может смещаться от своей обычной позиции.

3. `absolute`: Элемент удаляется из обычного потока документа, и его позиция определяется относительно его ближайшего позиционированного (не `static`) предка, если таковой имеется; в противном случае относительно начальной контейнерной области. Свойства `top`, `right`, `bottom` и `left` определяют его точное положение.

4. `fixed`: Элемент удаляется из обычного потока документа и позиционируется относительно окна браузера. Он остается на том же месте даже при прокрутке страницы. Свойства `top`, `right`, `bottom` и `left` также определяют его позицию.

5. `sticky`: Элемент является гибридом между `relative` и `fixed`. Он ведет себя как `relative` до тех пор, пока элемент не достигнет определенной точки при прокрутке страницы, после чего он становится "застрявшим" и ведет себя как `fixed`, пока не будет достигнута противоположная граница его контейнера.

Каждое из этих значений позволяет разработчику точно управлять расположением элементов на странице, делая возможным создание сложных макетов и интерактивных интерфейсов. Выбор конкретного значения `position` зависит от задачи, которую нужно решить, и желаемого визуального эффекта.